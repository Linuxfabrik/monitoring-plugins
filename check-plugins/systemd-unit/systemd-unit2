#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

"""Have a look at the check's README for further details.
"""

import os

# considering a virtual environment
ACTIVATE_THIS = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv2')
if os.path.exists(venv_path):
    ACTIVATE_THIS = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV2'):
    ACTIVATE_THIS = os.path.join(os.getenv('MONITORING_PLUGINS_VENV2') + 'bin/activate_this.py')

if ACTIVATE_THIS and os.path.isfile(ACTIVATE_THIS):
    exec(open(ACTIVATE_THIS).read(), {'__file__': ACTIVATE_THIS}) # pylint: disable=W0122


import argparse # pylint: disable=C0413
import sys # pylint: disable=C0413
from traceback import print_exc # pylint: disable=C0413

import lib.base2 # pylint: disable=C0413
from lib.globals2 import STATE_CRIT, STATE_OK, STATE_UNKNOWN, STATE_WARN # pylint: disable=C0413


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021070101'

DESCRIPTION = """Checks the state of a service, socket, device, mount, automount, swap, target,
                path, timer, slice or scope - using systemd/systemctl. For example, to check if the
                service "sshd" is running, use `systemd-unit --substate=running --unit=sshd`. Have a
                look at the README for more details."""

DEFAULT_ACTIVESTATE  = []
DEFAULT_LOADSTATE  = 'loaded'
DEFAULT_SERVERITY = 'warn'
DEFAULT_SUBSTATE  = []


def parse_args():
    """Parse command line arguments using argparse.
    """
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '--activestate',
        help='Expected systemd ActiveState (repeating). This is the high-level unit activation state(s), i.e. generalization of SUB. If ommited or set to "None", the unit\'s active state will not be checked.',
        dest='ACTIVESTATE',
        default=DEFAULT_ACTIVESTATE,
        action='append',
        choices=[
            'activating',
            'active',
            'deactivating',
            'failed',
            'inactive',
            'None',
        ],
    )

    parser.add_argument(
        '--loadstate',
        help='Expected systemd LoadState. Reflects whether the unit definition was properly loaded. If ommited or set to "None", the unit\'s load state will not be checked. Default: %(default)s',
        dest='LOADSTATE',
        default=DEFAULT_LOADSTATE,
        choices=[
            'activating',
            'active',
            'deactivating',
            'failed',
            'inactive',
            'loaded',
            'maintenance',
            'masked',
            'None',
            'not-found',
            'reloading',
        ],
    )

    parser.add_argument(
        '--severity',
        help='If something was found, the check returns WARN unless set here. One of "warn" or "crit". Default: %(default)s',
        dest='SEVERITY',
        default=DEFAULT_SERVERITY,
        choices=['warn', 'crit'],
    )

    parser.add_argument(
        '--substate',
        help='Expected systemd SubState (repeating). This is the low-level unit activation state(s); values depend on unit type. If ommited or set to "None", the unit\'s substate will not be checked.',
        dest='SUBSTATE',
        default=DEFAULT_SUBSTATE,
        action='append',
        choices=[
            'abandoned',
            'activating',
            'activating-done',
            'active',
            'auto-restart',
            'cleaning',
            'condition',
            'deactivating',
            'deactivating-sigkill',
            'deactivating-sigterm',
            'dead',
            'elapsed',
            'exited',
            'failed',
            'final-sigkill',
            'final-sigterm',
            'final-watchdog',
            'listening',
            'mounted',
            'mounting',
            'mounting-done',
            'None',
            'plugged',
            'reload',
            'remounting',
            'remounting-sigkill',
            'remounting-sigterm',
            'running',
            'start',
            'start-chown',
            'start-post',
            'start-pre',
            'stop',
            'stop-post',
            'stop-pre',
            'stop-pre-sigkill',
            'stop-pre-sigterm',
            'stop-sigkill',
            'stop-sigterm',
            'stop-watchdog',
            'tentative',
            'unmounting',
            'unmounting-sigkill',
            'unmounting-sigterm',
            'waiting',
        ],
    )

    parser.add_argument(
        '--unit',
        help='The unit name (service, timer, mount etc.). Required. For example "sshd", "sshd.service", "my-samba-mount.mount" etc.',
        dest='UNIT',
        required = True,
    )

    parser.add_argument(
        '--unitfilestate',
        help='Expected systemd UnitFileState. If ommited or set to "None", the unit\'s unit-file state will not be checked. If "empty", checks exactly for ``UnitFileState=""``.',
        dest='UNITFILESTATE',
        choices=[
            'bad',
            'disabled',
            'empty',
            'enabled',
            'enabled-runtime',
            'generated',
            'indirect',
            'linked',
            'linked-runtime',
            'masked',
            'masked-runtime',
            'None',
            'static',
            'transient',
        ]
    )

    return parser.parse_args()


def main():
    """The main function. Hier spielt die Musik.
    """

    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    command = 'systemctl show -p LoadState,ActiveState,SubState,UnitFileState '
    stdout, stderr, retc = lib.base2.coe(lib.base2.shell_exec(command + args.UNIT))
    if (stderr or retc != 0):
        lib.base2.oao('Bash command `{}` failed.\nStdout: {}\nStderr: {}'.format(command, stdout, stderr), STATE_UNKNOWN)
    result = stdout.split('\n')

    loadstate     = result[0].replace('LoadState=', '')
    activestate   = result[1].replace('ActiveState=', '')
    substate      = result[2].replace('SubState=', '')
    unitfilestate = result[3].replace('UnitFileState=', '')

    state = STATE_OK
    msg = '{} is {}, {}, {}'.format(args.UNIT, loadstate, activestate, substate)

    if args.LOADSTATE == 'None':
        args.LOADSTATE = None
    if 'None' in args.ACTIVESTATE:
        args.ACTIVESTATE = None
    if 'None' in args.SUBSTATE:
        args.SUBSTATE = None
    if args.UNITFILESTATE == 'None':
        args.UNITFILESTATE = None

    if args.UNITFILESTATE is not None:
        msg += ', UnitFileState is "{}".'.format(unitfilestate)

    # now do the checks
    problem = False
    problem_msg = ''
    if args.LOADSTATE is not None and loadstate == 'not-found':
        problem = True
        problem_msg += 'Unit {} not found.  '.format(args.UNIT)
    else:
        if args.LOADSTATE is not None and args.LOADSTATE != loadstate:
            problem = True
            problem_msg += 'LoadState is "{}", but supposed to be "{}"; '.format(loadstate, args.LOADSTATE)
        if args.ACTIVESTATE and activestate not in args.ACTIVESTATE:
            # ACTIVESTATE is not None and not empty
            problem = True
            problem_msg += 'ActiveState is "{}", but supposed to be "{}"; '.format(activestate, args.ACTIVESTATE)
        if args.SUBSTATE and substate not in args.SUBSTATE:
            # SUBSTATE is not None and not empty
            problem = True
            problem_msg += 'SubState is "{}", but supposed to be "{}"; '.format(substate, args.SUBSTATE)
        if args.UNITFILESTATE is not None and args.UNITFILESTATE != unitfilestate:
            problem = True
            problem_msg += 'UnitFileState is "{}", but supposed to be "{}"; '.format(unitfilestate, args.UNITFILESTATE)

    if problem:
        msg = '{} - '.format(args.UNIT) + problem_msg[:-2]
        state = STATE_CRIT if args.SEVERITY == 'crit' else STATE_WARN

    # over and out
    lib.base2.oao(msg, state)


if __name__ == '__main__':
    try:
        main()
    except Exception:   # pylint: disable=W0703
        print_exc()
        sys.exit(STATE_UNKNOWN)

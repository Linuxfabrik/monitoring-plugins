#! /usr/bin/env python2
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

"""Have a look at the check's README for further details.
"""

import os

# considering a virtual environment
ACTIVATE_THIS = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv2')
if os.path.exists(venv_path):
    ACTIVATE_THIS = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV2'):
    ACTIVATE_THIS = os.path.join(os.getenv('MONITORING_PLUGINS_VENV2') + 'bin/activate_this.py')

if ACTIVATE_THIS and os.path.isfile(ACTIVATE_THIS):
    exec(open(ACTIVATE_THIS).read(), {'__file__': ACTIVATE_THIS}) # pylint: disable=W0122


import argparse # pylint: disable=C0413
import sys # pylint: disable=C0413
from traceback import print_exc # pylint: disable=C0413

import lib.base2 # pylint: disable=C0413
from lib.globals2 import STATE_CRIT, STATE_OK, STATE_UNKNOWN, STATE_WARN # pylint: disable=C0413


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021061701'

DESCRIPTION = 'Checks the date and return code of the last borgbackup, according to the logfile.'

DEFAULT_CRIT = None
DEFAULT_WARN = 24


def parse_args():
    """Parse command line arguments using argparse.
    """
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '-c', '--critical',
        help='Set the critical threshold for the time difference to the start of the last backup (in hours). Default: %(default)s',
        dest='CRIT',
        type=int,
        default=DEFAULT_CRIT,
    )

    parser.add_argument(
        '-w', '--warning',
        help='Set the warning threshold for the time difference to the start of the last backup (in hours). Default: %(default)s',
        dest='WARN',
        type=int,
        default=DEFAULT_WARN,
    )
    
    return parser.parse_args()


def main():
    """The main function. Hier spielt die Musik.
    """

    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    perfdata = ''
    path = '/var/log/borg/borg.log'

    # content of the log file:
        # start: 2020-04-08 23:00:01
        # prune_retc: 0
        # create_retc: 0
        # end: 2020-04-08 23:00:13

    if os.path.exists(path) <= 0 and not os.path.isfile(path):
        lib.base2.oao('Logfile {} not found or empty.'.format(path), STATE_UNKNOWN)

    mount_lines = ''
    with open('/proc/mounts') as mountlist:
        for line in mountlist:
            if 'borgfs' in line:
                mount_lines += '* ' + line

    if mount_lines:
        lib.base2.oao('There are active borg mounts.\n\n{}'.format(mount_lines), STATE_WARN)


    logfile = open(path, 'rb')
    for line in logfile:
        if line.startswith('start'):
            starttime = line.split(": ")[1].strip()

        if line.startswith('end'):
            endtime = line.split(": ")[1].strip()

        if line.startswith('create_retc'):
            create_retc = int(line.split(": ")[1])

        if line.startswith('prune_retc'):
            prune_retc = int(line.split(": ")[1])

    # check if all variables are defined
    try:
        starttime
        endtime
        create_retc
        prune_retc
    except UnboundLocalError as e:
        lib.base2.oao('Could not find all expected values in the logfile.\n{}'.format(e), STATE_UNKNOWN)

    # We ignore retc 1, as it means operation reached its normal end, but there were warnings from borg.
    state = STATE_OK
    create_retc_state = lib.base2.get_state(create_retc, 2, None, operator='ge')
    state = lib.base2.get_worst(state, create_retc_state)
    perfdata += lib.base2.get_perfdata('create_retc', create_retc, None, 1, 2, 0, None)

    prune_retc_state = lib.base2.get_state(prune_retc, 2, None, operator='ge')
    state = lib.base2.get_worst(state, prune_retc_state)
    perfdata += lib.base2.get_perfdata('prune_retc', prune_retc, None, 1, 2, 0, None)

    now = lib.base2.now(as_type='iso')
    delta = lib.base2.timestrdiff(now, starttime)

    last_starttime_state = lib.base2.get_state(delta, args.WARN * 60 * 60 if args.WARN is not None else None, args.CRIT * 60 * 60 if args.CRIT is not None else None)
    state = lib.base2.get_worst(state, last_starttime_state)

    duration = lib.base2.timestrdiff(endtime, starttime)     # in seconds
    perfdata += lib.base2.get_perfdata('duration', duration, 's', None, None, 0, None)

    msg = 'Last Backup started {}, ended {}, took {}.\n'.format(starttime, endtime, lib.base2.seconds2human(duration))
    if state != STATE_OK:
        if last_starttime_state != STATE_OK:
            msg = 'Last backup is too long ago. ' + msg
        else:
            msg = 'One or more errors. ' + msg
    msg += '* Create retc: {}, State: {}\n'.format(create_retc, lib.base2.state2str(create_retc_state))
    msg += '* Prune retc: {}, State: {}'.format(prune_retc, lib.base2.state2str(prune_retc_state))

    # over and out
    lib.base2.oao(msg, state, perfdata)


if __name__ == '__main__':
    try:
        main()
    except Exception:   # pylint: disable=W0703
        print_exc()
        sys.exit(STATE_UNKNOWN)
